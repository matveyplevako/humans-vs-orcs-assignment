Matvey Plevako
B18-02
# Assignment 1 report
## Table of contents
1. **Algorithms code explanation**
    1. [Common rules used in algoritms](#common_rules)
    2. [Random Search](#random_search_code)
    3. [Backtracking](#backtracking_code)
    4. [Optimized backtracking](#optimized_backtracking_code)
3. **Review of solutions generated by algorithms**
    1. [Random Search](#random_search_results)
    2. [Backtracking](#backtracking_results)
    3. [Optimized backtracking](#optimized_backtracking_results)
4. **Statistical comparison of solutions generated by algorithms**
    1. [Comparison by time](#statistics_time)
    2. [Comparison by number of steps](#statistics_length)
6. **Answers to questions from assignment**
    1. [Increase in view range of players](#q1)
    2. [Hard to solve maps](#q2)
    3. [Impossible to solve maps](#q3)

## Common rules used in algoritms<a name="common_rules"></a>

### quantity
Just convenient reduction to use in another rules.
```prolog
quantity(Quantity) :-
	random_between(1, 10, Quantity).
```
output:
```prolog
?- quantity(Quantity).
Quantity = 7
```

 
### get_X_Y
rule to map uniquely map number to coordinates
```prolog
get_X_Y(H, [A, B]) :-
    A is H//10,
    B is H mod 10.
```
output:
```prolog
?- get_X_Y(100, [A, B]).
A = 6,
B = 7
```


### is_valid_move and is_valid_move_and_left_moves
rules to check if move to [I, J] is valid 
valid means that it does not left borders of the field and does not step into orck.
is_valid_move_and_left_moves also checks if moves are left for random search.
```prolog
is_valid_move_and_left_moves(MovesLeft, Orcks, I, J) :-
    MovesLeft > 0, % check that we have moves left
    is_valid_move(Orcks, I, J). % check that we can move in this direciton

is_valid_move(Orcks, I, J) :-
    I >= 0, I < 10, J >= 0, J < 10, 
    is_not_in(Orcks, [I, J]).
```
example where we step into Orck

output:
```prolog
?- is_valid_move_and_left_moves(27, [[1, 2], [3, 5]], 3, 5).
false
```

### split_seq3
split sequence of coordinates in 3 separate lists by specified number of elements in each list
```prolog
% fill 1st list
split_seq3([H|Seq], N1, N2, N3, [[Place|List1], List2, List3]) :-
    N1 \== 0,
    N1_1 is N1 - 1,
    get_X_Y(H, Place),
    split_seq3(Seq, N1_1, N2, N3, [List1, List2, List3]).
    
% fill 2nd list
split_seq3([H|Seq], N1, N2, N3, [List1, [Place|List2], List3]) :-
    N1 == 0, N2 \== 0,
    N2_1 is N2 - 1,
    get_X_Y(H, Place),
    split_seq3(Seq, N1, N2_1, N3, [List1, List2, List3]).

% fill 3rd list
split_seq3([H|Seq], N1, N2, N3, [List1, List2, [Place|List3]]) :-
    N1 == 0, N2 == 0, N3 \== 0,
    N3_1 is N3 - 1,
    get_X_Y(H, Place),
    split_seq3(Seq, N1, N2, N3_1, [List1, List2, List3]).

% terminal recursion case
split_seq3(_, 0, 0, 0, [[], [], []]).
```
output:
```prolog
% use with randseq to get sequence of numbers
?- randseq(10, 99, Rand_Seq), split_seq3(Rand_Seq, 2, 3, 4, [Humans, Orcks, Touchdown]).
Humans = [[5, 8], [4, 1]],
Orcks = [[5, 4], [9, 0], [2, 7]],
Touchdown = [[6, 3], [8, 4], [9, 8], [2, 6]]
```

### generate_map
rule to generate at random list with 3 items:
Humans positions, Orcks positions and Touchdown positions at.
```prolog
generate_map([Humans, Orcks, Touchdown]) :-
    randseq(99, 99, Rand_Seq),
    quantity(Human_Num),
    quantity(Orck_Num),
    quantity(Touchdown_Num),
    split_seq3(Rand_Seq, Human_Num, Orck_Num, Touchdown_Num, [Humans, Orcks, Touchdown]).
```
output:
```prolog
?- generate_map([Humans, Orcks, Touchdown]).
Humans = [[1, 4], [6, 5], [8, 3], [5, 2], [9, 1], [1, 9], [1, 7]],
Orcks = [[7, 7], [3, 5], [3, 3], [4, 9], [2, 2], [0, 3]],
Touchdown = [[9, 2], [3, 9], [6, 8], [6, 2]]
```

### draw_map
prints map generated by generate_map

0 is empty

1 is Human

2 is Orck

3 is Touchdown

S is starting point

```prolog
draw_map(Count, Humans, Orcks, Touchdown) :-
    Count < 100,
    get_X_Y(Count, [I, J]),
    ((J == 0, I \= 0) -> nl; true),
    draw_point([I, J], Humans, Orcks, Touchdown),
    Count1 is Count + 1,
    draw_map(Count1, Humans, Orcks, Touchdown).

draw_point(Point, Humans, Orcks, Touchdown) :- 
    (   is_in(Touchdown, Point) ->  Message ='3';
    (   is_in(Humans, Point) ->  Message ='1';
    (   is_in(Orcks, Point) ->  Message ='2';
    (   (Point == [0, 0]) ->  Message ='S';
    	Message = '0'
    )))), write(Message).
    
draw_map(100, _, _, _).
```
output:
```prolog
?- generate_map([Humans, Orcks, Touchdown]), draw_map(0, Humans, Orcks, Touchdown).

S302002002
0131130002
0100030110
2001000200
2100000103
0110000200
1000002020
1200002102
1010200210
1002002001
```

### throw_ball
rule to simulate the ball throw in direction di, dj with respect to the origin

if success - returns coordinates of human that catched the ball

if fail - rule fail
```prolog
throw_ball([Humans, Orcks, Touchdown], Di, Dj, I, J, R_I, R_J) :-
    I_1 is I + Di,
    J_1 is J + Dj,
    is_valid_move(Orcks, I_1, J_1),
    is_not_in(Humans, [I_1, J_1]),
    throw_ball([Humans, Orcks, Touchdown], Di, Dj, I_1, J_1, R_I, R_J).

throw_ball([Humans, Orcks, _], Di, Dj, I, J, R_I, R_J) :-
    I_1 is I + Di,
    J_1 is J + Dj,
    is_valid_move(Orcks, I_1, J_1),
    is_in(Humans, [I_1, J_1]),
    R_I = I_1,
    R_J = J_1.
```

example, where human at 0, 0 throws ball in diagonal 

direction at random map, and human at 7, 7 cathes it.

output:

```prolog
?- generate_map([Humans, Orcks, Touchdown]), throw_ball([Humans, Orcks, Touchdown], 1, 1, 0, 0, R_I, R_J).
R_I = R_J, R_J = 7
```




## Random Search explanation <a name="random_search_code"></a>
To run random search, call
`random_search(Path, NumberOfMoves, T, ThrowPoint).`
It will print map and then output variables
Path, NumberOfMoves, T, ThrowPoint.

round - attempt to solve map by stepping in random direction on each move until touchdown or fail.

This method uses 200 rounds, and each round is limited to 100 steps to find solution.

each step it chooses with probability 1/12 to throw ball or not, if throws are left.

Otherwise, step in random direction.


defenition of main rule for starting random search.

It uses random_search_round that represents single round.
```prolog
random_search([[0, 0]|List], Moves, Touchdown, ThrowPoint) :-
    generate_map([Humans, Orcks, Touchdown]),
    random_search_round(200, [Humans, Orcks, Touchdown], List, Moves, ThrowPoint),
    (Moves \= 200 -> 
    true;(write('No solution'), nl, true)),
    draw_map(0, Humans, Orcks, Touchdown).
```

definition of single round that starts random search from point 0, 0.

After round, call next random_search_round and compare results and choose the best path.

```prolog
random_search_round(Count, [Humans, Orcks, Touchdown], BestList, BestMoves, BestThrowPoint) :-
    Count > 0,
    (random_step([Humans, Orcks, Touchdown], 0, 0, 100, List, Moves, 1, ThrowPoint) -> true;
    Moves = 200, List = []),
    Count1 is Count - 1,
    random_search_round(Count1, [Humans, Orcks, Touchdown], PreviousList, PreviousMoves, PreviousThrowPoint),
    (Moves < PreviousMoves -> ((BestMoves is Moves), (BestList = List), (BestThrowPoint = ThrowPoint));
    ((BestMoves is PreviousMoves), (BestList = PreviousList), (BestThrowPoint = PreviousThrowPoint))).

random_search_round(0, _, [], 200, -1).
```

defenition of random_step that goes through the map until it find touchdown or bumps into Orck or wall

On each step it decides at random to step in near cell or throw ball

If steps into wall or Orck - fails.
```prolog
random_step([_, _, Touchdown], I, J, 0, [], 0, _, -1) :-
    is_in(Touchdown, [I, J]).

random_step([Humans, Orcks, Touchdown], I, J, MovesLeft, List, FinalMoves, Throws, ThrowPoint) :-
    is_valid_move_and_left_moves(MovesLeft, Orcks, I, J),
    is_in(Touchdown, [I, J]),
    random_step([Humans, Orcks, Touchdown], I, J, 0, List, FinalMoves, Throws, ThrowPoint).

random_step([Humans, Orcks, Touchdown], I, J, MovesLeft, [H|List], FinalMoves, Throws, ThrowPoint) :-
    is_valid_move_and_left_moves(MovesLeft, Orcks, I, J),
    is_not_in(Touchdown, [I, J]),
    (Throws == 1, random_between(1, 12, WillThrow), WillThrow == 1 ->  
	(CurrentMove = 1,
     ThrowsLeft = 0,
        					%  up    up-right right right-down  down    down-left   left   up-left      
    random_member([Di, Dj], [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]]),
    throw_ball([Humans, Orcks, Touchdown], Di, Dj, I, J, I_1, J_1));
    (ThrowsLeft = Throws,
    random_member([Di, Dj], [[1, 0], [0, 1], [-1, 0], [0, -1]]),
    I_1 is I + Di,
    J_1 is J + Dj,
    (is_in(Humans, [I_1, J_1]) -> CurrentMove = 0; CurrentMove = 1))),
    Left is MovesLeft-CurrentMove,
    H = [I_1, J_1],
    random_step([Humans, Orcks, Touchdown], I_1, J_1, Left, List, PreviousMoves, ThrowsLeft, NextThrowPoint),
    (Throws == 1, WillThrow == 1 -> ThrowPoint = [I, J]; ThrowPoint = NextThrowPoint),
    FinalMoves is CurrentMove + PreviousMoves.
```
Example:
```prolog
?-random_search(Path, NumberOfMoves, Touchdown, ThrowPoint).

S100000300
0000000000
0000003300
0000000000
0020000001
0000002001
0010000000
0200000000
0000130010
0000000000
NumberOfMoves = 8,
Path = [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [1, 6], [2, 6]],
ThrowPoint = [0, 0],
Touchdown = [[0, 7], [2, 6], [2, 7], [8, 5]]
```


### Backtracking <a name="backtracking_code"></a>
To run Backtracking, call

`backtracking_search(Path, NumberOfMoves).`
It will print map and then output variables
Path, NumberOfMoves.

Uses prolog tree to brute force all possible paths. And then choose the best.

Map is restricted to 5 by 5, to minimize the time brute force takes to solve generated map.

One rule per possible step.

Each step recursively moves one step or throw a ball and calls itself.



defenition of main rule for starting backtracking search.

It uses backtracking_step that represents single possible move from point [I, J].

```prolog
backtracking_search([[0, 0]|BestPath], BestMoves) :-
    generate_map([Humans, Orcks, Touchdown]),
    draw_map(0, Humans, Orcks, Touchdown),
    setof([Moves, Path], backtracking_step([Humans, Orcks, Touchdown], 0, 0, 50, Path, [], Moves, 1), [[BestMoves, BestPath]|_]).
```

definitions of steps in backtracking that step
Before each step checks if it is not on touchdown, otherwise stops.
```prolog
% Touchdown point
backtracking_step([_, _, Touchdown], I, J, _, [], _, 0, _) :-
    is_in(Touchdown, [I, J]).

% step up
backtracking_step([Humans, Orcks, Touchdown], I, J, MovesLeft, [H|Path], Used, Moves, Throws) :-
    I_1 is I + 1,
    H = [I_1, J],
    next_step_conditions([Humans, Orcks, Touchdown], MovesLeft, I, J, I_1, J, Used, H, Left, CurrentMove),
    backtracking_step([Humans, Orcks, Touchdown], I_1, J, Left, Path, [[I, J]|Used], PreviousMoves, Throws),
    Moves is PreviousMoves + CurrentMove.

% step down
backtracking_step([Humans, Orcks, Touchdown], I, J, MovesLeft, [H|Path], Used, Moves, Throws) :-
    I_1 is I - 1,
    H = [I_1, J],
    next_step_conditions([Humans, Orcks, Touchdown], MovesLeft, I, J, I_1, J, Used, H, Left, CurrentMove),
    backtracking_step([Humans, Orcks, Touchdown], I_1, J, Left, Path, [[I, J]|Used], PreviousMoves, Throws),
    Moves is PreviousMoves + CurrentMove.

% step left
backtracking_step([Humans, Orcks, Touchdown], I, J, MovesLeft, [H|Path], Used, Moves, Throws) :-
    J_1 is J - 1,
    H = [I, J_1],
    next_step_conditions([Humans, Orcks, Touchdown], MovesLeft, I, J, I, J_1, Used, H, Left, CurrentMove),
    backtracking_step([Humans, Orcks, Touchdown], I, J_1, Left, Path, [[I, J]|Used], PreviousMoves, Throws),
    Moves is PreviousMoves + CurrentMove.


% step right
backtracking_step([Humans, Orcks, Touchdown], I, J, MovesLeft, [H|Path], Used, Moves, Throws) :-
    J_1 is J + 1,
    H = [I, J_1],
    next_step_conditions([Humans, Orcks, Touchdown], MovesLeft, I, J, I, J_1, Used, H, Left, CurrentMove),
    backtracking_step([Humans, Orcks, Touchdown], I, J_1, Left, Path, [[I, J]|Used], PreviousMoves, Throws),
    Moves is PreviousMoves + CurrentMove.

% throw ball up
backtracking_step([Humans, Orcks, Touchdown], I, J, MovesLeft, [H|Path], Used, Moves, Throws) :-
    throw_ball_common_part([Humans, Orcks, Touchdown], 1, 0, I, J, MovesLeft, H, Path, Used, Moves, Throws).
   
% throw ball
backtracking_step([Humans, Orcks, Touchdown], I, J, MovesLeft, [H|Path], Used, Moves, Throws) :-
    throw_ball_common_part([Humans, Orcks, Touchdown], 1, 1, I, J, MovesLeft, H, Path, Used, Moves, Throws).
   
% throw ball
backtracking_step([Humans, Orcks, Touchdown], I, J, MovesLeft, [H|Path], Used, Moves, Throws) :-
    throw_ball_common_part([Humans, Orcks, Touchdown], 0, 1, I, J, MovesLeft, H, Path, Used, Moves, Throws).
   
% throw ball
backtracking_step([Humans, Orcks, Touchdown], I, J, MovesLeft, [H|Path], Used, Moves, Throws) :-
    throw_ball_common_part([Humans, Orcks, Touchdown], -1, 1, I, J, MovesLeft, H, Path, Used, Moves, Throws).
   
% throw ball
backtracking_step([Humans, Orcks, Touchdown], I, J, MovesLeft, [H|Path], Used, Moves, Throws) :-
    throw_ball_common_part([Humans, Orcks, Touchdown], -1, 0, I, J, MovesLeft, H, Path, Used, Moves, Throws).
   
% throw ball
backtracking_step([Humans, Orcks, Touchdown], I, J, MovesLeft, [H|Path], Used, Moves, Throws) :-
    throw_ball_common_part([Humans, Orcks, Touchdown], -1, -1, I, J, MovesLeft, H, Path, Used, Moves, Throws).
   
% throw ball
backtracking_step([Humans, Orcks, Touchdown], I, J, MovesLeft, [H|Path], Used, Moves, Throws) :-
    throw_ball_common_part([Humans, Orcks, Touchdown], 0, -1, I, J, MovesLeft, H, Path, Used, Moves, Throws).
   
% throw ball
backtracking_step([Humans, Orcks, Touchdown], I, J, MovesLeft, [H|Path], Used, Moves, Throws) :-
    throw_ball_common_part([Humans, Orcks, Touchdown], 1, -1, I, J, MovesLeft, H, Path, Used, Moves, Throws).
   


throw_ball_common_part([Humans, Orcks, Touchdown], Di, Dj, I, J, MovesLeft, H, Path, Used, Moves, Throws) :-
    Throws > 0,
    is_not_in(Touchdown, [I, J]),
    is_valid_move_and_left_moves(MovesLeft, Orcks, I, J),
    throw_ball([Humans, Orcks, Touchdown], Di, Dj, I, J, I_1, J_1),
    H = [I_1, J_1],
    Left is MovesLeft - 1,
    backtracking_step([Humans, Orcks, Touchdown], I_1, J_1, Left, Path, [[I, J]|Used], PreviousMoves, 0),
    Moves is PreviousMoves + 1.


next_step_conditions([Humans, Orcks, Touchdown], MovesLeft, I, J, I_1, J_1, Used, H, Left, CurrentMove) :-
    is_not_in(Touchdown, [I, J]),
    is_valid_move_and_left_moves(MovesLeft, Orcks, I, J),
    is_not_in(Used, H),
    Left is MovesLeft-1,
    (is_in(Humans, [I_1, J_1]) -> CurrentMove = 0; CurrentMove = 1).
```
Example:
```prolog
?-backtracking_search(Path, Moves).

S0022
22100
20123
20022
00021
Moves = 5,
Path = [[0, 0], [0, 1], [0, 2], [1, 2], [1, 3], [1, 4], [2, 4]]
```

## Optimized backtracking <a name="optimized_backtracking_code"></a>
To run Optimized backtracking, call
`optimized_backtracking_search(Path, BestMoves).`
It will print map and then output variables
Path, NumberOfMoves.

**Optimization**
If we find solution at step N, we must cut all paths that exceed this length as they wont be shorter than this one.

This is done by maintaing the fact with the shortest path found.

When new move is to be made, it firstly check if it is no longer than current shortest path, otherwise it fails.

Implementation details are the same as in backtracking.
Except now we check for one more condition.

In backtracking_step with touchdown point now we update shortest path length.

And in next_step_conditions we check that current path length does not exceed already found minimal solution.
```prolog
optimized_backtracking_search([[0, 0]|BestPath], BestMoves) :-
    generate_map([Humans, Orcks, Touchdown]),
    draw_map(0, Humans, Orcks, Touchdown),
    setof([Moves, Path], backtracking_step([Humans, Orcks, Touchdown], 0, 0, 50, Path, [], 0, Moves, 1), [[BestMoves, BestPath]|_]).
    
:-dynamic minimal_depth_solution/1.

% Touchdown point
backtracking_step([_, _, Touchdown], I, J, _, [], _, Depth, 0, _) :-
    is_in(Touchdown, [I, J]),
    retract(minimal_depth_solution(_)), 
    assertz(minimal_depth_solution(Depth)). % update minimal length to solution
    
next_step_conditions([Humans, Orcks, Touchdown], MovesLeft, I, J, I_1, J_1, Used, H, Depth, Left, CurrentMove, NextDepth) :-
    is_not_in(Touchdown, [I, J]),
    is_valid_move_and_left_moves(MovesLeft, Orcks, I, J),
    is_not_in(Used, H),
    minimal_depth_solution(D), Depth < D, % check for length
    Left is MovesLeft-1,
    (is_in(Humans, [I_1, J_1]) -> CurrentMove = 0; CurrentMove = 1),
    NextDepth is CurrentMove + Depth.
```
Example:
```prolog
?-optimized_backtracking_search(Path, Moves).

S001000020
0020000000
0100002000
0200021120
0100000001
3110200000
3000000032
1100000000
0030030000
2002011100
Moves = 2,
Path = [[0, 0], [7, 0], [6, 0]]
```

## Review of solutions generated by algorithms
This plots were made with python script that uses matplotlib library. 

Script for generating `plot_maps.py` from symbolic representation is in submission archive.

white - empty

blue - human

green - orck

yellow - touchdown point

red - path

## Random search <a name="random_search_results"></a>
### Success
Map:
![](https://i.imgur.com/B5nkCda.png)
Solution by random search: (length 8)
![](https://i.imgur.com/BKho1ys.png)
Map:
![](https://i.imgur.com/kBAkDnG.png)
Solution by random search: (length 3)
![](https://i.imgur.com/2k7Syws.png)
Map:
![](https://i.imgur.com/gOBA9B6.png)
Solution by random search: (length 7)
![](https://i.imgur.com/uKX471F.png)
Map:
![](https://i.imgur.com/8jCMcif.png)
Solution by random search: (length 1)
![](https://i.imgur.com/cYLGj4d.png)

### Maps, that algorithm fail to solve
Touchdown is far away, so probability to step into right direction is low.
![](https://i.imgur.com/AgMVjlF.png)
![](https://i.imgur.com/yzBwlo9.png)
![](https://i.imgur.com/E0KWqS1.png)
![](https://i.imgur.com/IhtfCB3.png)


## Backtracking search <a name="backtracking_results"></a>
### Success

Map:

![](https://i.imgur.com/VaOFmTg.png)

Solution by backtracking search: (length 1)

![](https://i.imgur.com/fH1tRoi.png)

Map:

![](https://i.imgur.com/NL1MzfC.png)

Solution by backtracking search: (length 3)

![](https://i.imgur.com/bS4kdYC.png)

Map:

![](https://i.imgur.com/9J6jzez.png)

Solution by backtracking search: (length 2)

![](https://i.imgur.com/K7ZlE8K.png)

Map:

![](https://i.imgur.com/5DycPoZ.png)

Solution by backtracking search: (length 2)

![](https://i.imgur.com/OvsKj3M.png)

### Maps, that algorithm fail to solve
Backtracking fails if starting point or touchdown are isolated by wall of orcks.

![](https://i.imgur.com/2WRDOhe.png)

![](https://i.imgur.com/L9cD6Mv.png)

![](https://i.imgur.com/ZgMbziR.png)


## Optimized backtracking search <a name="optimized_backtracking_results"></a>
### Success

Map:

![](https://i.imgur.com/4Ncstw4.png)

Solution by optimized backtracking search: (length 8)

![](https://i.imgur.com/OJqfY72.png)

Map:

![](https://i.imgur.com/RMI6izz.png)

Solution by optimized backtracking search: (length 6)

![](https://i.imgur.com/iIbEeIR.png)

Map:

![](https://i.imgur.com/BQ7aCTG.png)

Solution by optimized backtracking search: (length 5)

![](https://i.imgur.com/eIhoiNT.png)

Map:

![](https://i.imgur.com/4djlBTs.png)
Solution by optimized backtracking search: (length 3)
![](https://i.imgur.com/CdJoOPv.png)

### Maps, that algorithm fail to solve
Same as usual backtrack, fails when there is a wall between touchdown and starting point.
![](https://i.imgur.com/LERESmd.png)
![](https://i.imgur.com/EsuRDUL.png)
![](https://i.imgur.com/UWjAEbh.png)

## Statistical comparison of solutions generated by algorithms 
## Comparison by time <a name="statistics_time"></a>
It makes sence to compare time taken to get the solution for backtracking and optimized backtracking, but not random search, as it does not find optimal solution.


| Backtracking search | Optimized backtracking search |
| -------- | -------- |
| 14,893 | 2,755 | 
| 11,300 | 2,412 | 
| 12,875 | 3,205 | 
| 17,219 | 2,032 | 
| 20,545 | 4,086 | 
| 12,763 | 2,565 | 
| 18,006 | 2,898 | 
| 12,466 | 3,037 | 
| 18,286 | 2,772 | 
| 15,369 | 2,840 | 
| 19,701 | 2,447 | 
| 15,512 | 3,198 | 
| 10,498 | 2,862 | 
| 19,481 | 3,992 | 
| 17,890 | 2,192 | 
| 12,650 | 3,990 | 
| 9,988 | 3,770 | 
| 14,793 | 3,224 | 
| 10,879 | 2,959 | 
| 16,253 | 2,484 | 
| 16,219 | 3,558 | 
| 12,667 | 3,776 | 
| 14,655 | 3,240 | 
| 13,457 | 3,378 | 
| 20,396 | 2,828 | 
| 15,551 | 3,285 | 
| 13,049 | 2,664 | 
| 16,242 | 2,907 | 
| 7,858 | 2,566 | 
| 13,802 | 2,859 |


| | Backtracking search | Optimized backtracking search|
| -------- | -------- | -------- |
| **Mean**| 14,842   |   3,026  |
| **STD** |  3,224337154 | 0,5340254095|

T-Test
 ![](https://i.imgur.com/9DUDX6V.png)
 t = 19.8022 
 p value is < .05 => results are statistically significant
 
## Comparison by length <a name="statistics_length"></a>
As a second comparison we can take length of the solution by random search and backtracking search.


| Random search | Optimized backtracking search | 
| -------- | -------- |
| 8 | 6 | 
| 11 | 4 | 
| 4 | 4 | 
| 4 | 1 | 
| 4 | 7 | 
| 5 | 2 | 
| 0 | 3 | 
| 5 | 4 | 
| 5 | 1 | 
| 7 | 7 | 
| 7 | 3 | 
| 4 | 4 | 
| 4 | 1 | 
| 10 | 8 | 
| 3 | 7 | 
| 13 | 1 | 
| 9 | 1 | 
| 3 | 3 | 
| 9 | 1 | 
| 7 | 3 | 
| 5 | 4 | 
| 6 | 9 | 
| 2 | 4 | 
| 5 | 7 | 
| 1 | 5 | 
| 13 | 1 | 
| 6 | 4 | 
| 7 | 5 | 
| 5 | 1 | 
| 6 | 4 | 


| | Random search | Optimized backtracking search | 
| -------- | -------- | -------- |
| **Mean**| 6 | 4 |
| **STD** | 3,139661011 | 2,364731279 |

t value = 2.7870 
p value is < .05 => results are statistically significant

## Answers to questions from assignment 
### Increase in view range of players <a name="q1"></a>
#### Question
Your team has become more advanced in the ways of Orc Rugby and can now see 2 yards rather than one.
Run the same experimental method as above – are there any significant changes with this new ability?
#### Answer
Increase of view range does not affect any of provided algorithms.
Random search does not depend on any near point, it just select at random next move.
Backtracking solves problem by generating all possible outcomes and selecting the best, so it is not affected also.

### Hard to solve maps <a name="q2"></a>
#### Question
What arrangements of Orcs, Humans, and goal points that are hard to solve?
#### Answer
For random search it is the position of touchdown. The far away it from start, the more successful moves search have to made, so the probability is lower.
For backtracking, the number of empty cells affect the search, as we have more options to consider.
For optimized backtracking, the number of people affect the search, as people does not increase the length of the path, so we have more options to consider.

### Impossible to solve maps <a name="q3"></a>
#### Question
What arrangements of Orcs, Humans, and goal points that are impossible to solve?
#### Answer
As mentioned in search review for backtracking and optimized backtracking, it is impossible to solve if we have wall of ocrks between starting point and touchdown as there is no path between them.
